# 回文整数

程序是怎么设计的

# CPU

比 GPU 慢的多

## 早期

1.串行执行指令 (执行一个一个) 25 个
数据存在磁盘中，而 CPU 却很快，CPU 就会一直等待

## 改进 并行执行指令 9 个

流水线式
1 个时钟周期

## 指令寄存器操作

- F:取指令
- D1:取数据
- D2:数据预解析
- EX:执行
- WB:写回操作

# CPU 的分支预测 \***\*\*\*\*\***

对于逻辑处理代码，CPU 不知道下一步怎么处理，
一般的会按照之前的逻辑去处理，这个现象叫做
CPU 的分支预测，
对我们的启示在于写代码的时候，
应该尽量避免，多余的逻辑处理（if else）

- switch 在底层也要比 if 快一些
- 三目运算相对最快

# GPU

最快

# 循环语句

## while

## do while

## for 循环

for(初始化；循环条件；执行后操作){
代码块；
}

- step1:初始化
- step2:循环条件
- step3:代码块
- step4:执行后操作
- step5:新的循环条件（step2）

### for 是当型循环（至少执行 0 次）

- 至少执行 0 次
- 其中 初始化，循环条件；执行后操作都可以不写

## ++i 比 i++ 快 原因是因为++i 是直接操作变量，而 i++是对变量的操作

## ++i 与 i++

### 寄存器运算方式

```c
int i=0;
printf("a++ =%d\n",(a++));//0
// 寄存器先自加
printf("a++ =%d\n",a);//1
```
# 伪随机
计算机上生成的数都是伪随机
```c
#include <stdlib.h> //rand() random生成随机数字 返回int
int a= rand()%100 //0-100
int a= rand()%100+1 //1-101
//生成a-b的数
```
## 计算机中是通过随机种子生成随机数的，
## 随机种子就是一种生成随机数的序列，
## 随机种子不改变，生成的随机数都是按照这样的方式生成的
## 通过srand(time(0))生成随机种子