# vue01-预习

## SAP 应用 router-view 实现原理

### 不能离开当前页面，同时需要知道页面确实发生了变化

1. url+# 哈希值

url 发生变化，但是页面其实没有跳转
![路由变化](../image/1-1.jpg)
监听 hashChange => 查找路由表 => 绑定 router-view =>执行 render(h)=>h(component)=>触发重新渲染

1. H5 的 history API 页面依然不跳转

## vuex **实现原理**

![vuex原理](/image/1.jpg)

1. 需要构建一个 store 对象，具有 commit,dispatch 的方法，
2. 需要调用 init 方法实现 render

### 需要掌握

1. vue plugin
2. render(h)
3. 数据响应式 vue.util.defineReactive
   new Vue(data(){})
4. es6 class

## 直播课

### Vue 的设计思想

将视图 view 的状态和行为抽象化，让我们将视图 UI 和业务逻辑分开。
![mvvm原理](/image/2.jpg)
mvvm 框架的三要素，数据响应式，模板引擎，渲染

1. 数据响应式
   objet.defineProperty()
   proxy
2. 模板引擎
   插值表达式：{{}}
   指令：v-bind,v-on,v-model,v-for,v-if
3. 渲染 如何将模板渲染为 html
   模板->vdom->dom

**问题：计算属性底层也是通过 defineProperty 来做精确的数据响应式操作**

### kvue/01-reactive.js

defineReactive 的功能是封装了一个方法，使给传进来的 obj 一个响应式的属性

### kvue/02.reactive.html

需要实现的内容就是如何进行数据的响应式更新，
实现 update 是需要在 set 阶段进行的

### kvue/01-reactive.js

- 但是，日常使用的过程中，defineReactive(obj, "foo", "foo");有可能会被执行很多次
  这个时候就需要一个 observe 方法，遍历响应式处理

```js
// 遍历响应式处理，即处理的响应式很多，需要监听当前处理过程
function observe(obj) {
  if (typeof obj !== "object" || typeof obj == null) {
    return;
  }
  Object.keys(obj).forEach((key) => defineReactive(obj, key, obj[key]));
}

const obj = {
  foo: "foo",
  bar: "bar",
};
// defineReactive(obj, "foo", "foo");
observe(obj);
obj.foo;
```

- 但是，当出的对象存在嵌套问题，就不会监听到对象的方法上的监听

```js
const obj = {
  foo: "foo",
  bar: "bar",
  baz: {
    n: 1,
  },
};
observe(obj);
obj.baz.n; //get baz
```

- 这个时候就需要做一层处理，即监听的对象的元素是一个对象，形如 obj.baz.n,就先对子元素进行监听

```js
function defineReactive(obj, key, val) {
  //递归，如果val 即监听的对象的元素是一个对象，形如obj.baz.n,就先对子元素进行监听
  observe(val); //get bas; get n
```

- 还有一种情况，当用户直接给监听对象赋值操作的时候，也监听不到

```js
const obj = {
  foo: "foo",
  bar: "bar",
  baz: {
    n: 1,
  },
};
observe(obj);
obj.baz = {
  n: 22,
};
obj.baz.n; //set baz;get baz
```

- 解决办法就是在 defineReactive 的 set 操作为新值的时候，添加一层监听

```js
function defineReactive(obj, key, val) {
    set(newVal) {
      if (newVal !== val) {;
        // 当用户直接替换属性时，添加监听
        observe(newVal);
      }}
```

- 假设监听的对象新增了一条属性，添加属性

```js
observe(obj);
obj.tool = "tool";
obj.tool; // 什么也没有发生
```

- 这样的话，就需要创建一个 set 方法，重新执行一遍 defineReactive 方法，
  并且强制用户使用定义的 set 方法进行新属性的添加

```js
function set(obj, key, val) {
  defineReactive(obj, key, val);
}
set(obj, "tool", "tool");
obj.tool; //get tool
```
